---
title: Creating more effective tests
description: How to get more value by writing less tests
date: '2022-01-21'
dateUpdated: '2022-01-21'
bannerId: 7E2ZI7pmLjYwclCitRLek
bannerDescription: eye test
tags: ['testing']
keywords: ['test', 'jest', 'react']
published: true
---


<HalfScreen />

# Problem

<h2 style={{textAlign: 'center'}}>Tests that take forever to run</h2>

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/sign/img/testing-meme.png?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJpbWcvdGVzdGluZy1tZW1lLnBuZyIsImlhdCI6MTY0MjUyMTA5NCwiZXhwIjoxOTU3ODgxMDk0fQ.kBnV7cTpCxx70qup9RozOjiSNLLx4Ju0h_V15NnHfg0" />


<HalfScreen />


# Why do we care?

### Having a well-defined tests, not only give the business-side a sense of product maintainability, it also give developers more confidence to make changes without breaking crucial functionality.

> As automation practices(CI/CD, DevOps) become common now, it is important to know that automated test is a key factor to make it work.

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/sign/img/cicd-pipelines_devops.webp?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJpbWcvY2ljZC1waXBlbGluZXNfZGV2b3BzLndlYnAiLCJpYXQiOjE2NDI1MTY2NDYsImV4cCI6MTk1Nzg3NjY0Nn0.DZtesM4TZKTnzx_-w8Ec8I_o6NTirUZLfvaygddZnB0" />

<HalfScreen />

# Is unit testing slow?


<HalfScreen />

# Unit test is supposed to be fast.

## If your test is slow, you are probably doing something wrong.

<HalfScreen />

# Why tests are running slow in my pipeline?

<HalfScreen />

# Too many tests... ü§Ø

<HalfScreen />

# Concerete example

<h3 style={{textAlign: 'center'}}>Due to the hardcore practice of TDD, early adopters of the convention tried to write tests everything (even the trivial ones).</h3>

```jsx
test('Initialize OrderLog component', () => {
	const props = {
		url: 'customer-support/orders/order-log/10085807',
		match: {
			params: { id: 10085807 },
		},
	}
	const wrapper = shallow(<OrderLog {...props} />)

	expect(wrapper).toBeTruthy()
})
```

<HalfScreen />


## As days, weeks, months, and years pass, developers come and go; new developers start refactoring the code according to what they see fit.
## However, some developers do not dare touch the unit tests that are already working.


<br />

### How come those "orphaned test case" still exists?

<HalfScreen />

<Img src="https://i.imgur.com/tDHXanY.gif" />

<HalfScreen />

# What is the solution???

<HalfScreen />

# ‚õîÔ∏è Warning ‚õîÔ∏è

<h2 style={{textAlign: 'center'}}>Other's might find this subjective</h2>

<h3 style={{textAlign: 'center'}}>Viewer's discretion is advised</h3>


<HalfScreen />

# Design your tests to a level where you can get around 90% coverage with lesser tests

<HalfScreen />

# It is easier said than done, isn't it? ü§¶üèª‚Äç‚ôÇÔ∏è

<HalfScreen />

# How can we get a 100% coverage?

```js
const oneOutput = () => 'foo';

// test file
test('oneOutput() should return foo', () => {
	expect(oneOutput()).toBe('foo');
})
```

<HalfScreen />

# Conditional branching

```js
const twoOutputs = (bool) => {
  if (bool === true) {
    return 'foo';
  }

  return 'bar';
}

// test files
test('twoOutputs(true) should return foo', () => {
	expect(twoOutputs(true)).toBe('foo');
})

test('twoOutputs(false) should return foo', () => {
	expect(twoOutputs(false)).toBe('bar');
})
```

<HalfScreen />

# Demo of the feature we are going to test

<h2 style={{textAlign: 'center'}}>Marketing Challenges Campaign</h2>

- ### Challenges Listing Page
- ### Add Challenge Page
- ### Edit(with Delete) Challenge Page

<HalfScreen />

# How to create tests for cases with multiple scenarios

1. ### Create a setup function that will resemble the initial state of the application
2. ### Mock the server responses using tools such as [MSW](https://mswjs.io/)
3. ### Create a utility function for repeated behavior
4. ### Create a test case for each scenario

<HalfScreen />

# Or you prefer to test this way

```jsx fileName=Details.test
test('It should not render delivery order actions menu for completed order', async () => {
	jest.mock('../../../../lib/api', (orderResp) => {
			const mock = require('../../../../../mocks')
			return jest.fn(function () {
					(this.cancel = () => { }),
							(this.get = () =>
									Promise.resolve({
											code: 200,
											status: 'SUCCESS',
											data: {
													config: {
															communication: {
																	allowCall: null,
																	allowEmail: null,
																	allowSms: null
															}
													},
											},
											deliveryOrder: mock.deliveryOrderResponse.deliveryOrder
									})
							),
							(this.post = () =>
									Promise.resolve({ code: 200 })
							)
			})
	})

	const props = {
			url: 'operations/delivery-orders/70032370',
			router: {
					match: {
							params: { id: 70032370 },
							url: 'operations/delivery-orders/70032370',
					}
			},
			history: ['/']
	}

	const DeliveryOrderDetailsView = require('./index').default
	const { container, getByText,
			getByLabelText, getByTestId } = render(
					<MemoryRouter>
							<DeliveryOrderDetailsView
									{...props}
							/>
					</MemoryRouter>
			)

	await waitForExpect(() => {
		expect(getByText('70032370')).toBeInTheDocument()
		expect(getByText('Pending')).toBeInTheDocument()
		expect(container.querySelector(`div[class='dropdown-menu hidden']`)).toBeInTheDocument()
	})

	const modalPortal = document.createElement('div');
	modalPortal.setAttribute('id', 'portal');
	document.body.append(modalPortal);

	const openAction = getByTestId('order-status-actions-icon-web');
	fireEvent.click(openAction);
	await waitForExpect(() => {
			expect(container.querySelector(`div[class='dropdown-menu']`)).toBeInTheDocument()
			expect(getByText('Pack Order')).toBeInTheDocument()
	})

	const packOrder = getByText('Pack Order')
	fireEvent.click(packOrder)

	await waitForExpect(() => {
			expect(getByText('Submit')).toBeInTheDocument()
			expect(getByText('Full Pick')).toBeInTheDocument()
	})
	fireEvent.click(getByLabelText('Full Pick'))

	await waitForExpect(() => {
			expect(getByText('Submit')).toBeInTheDocument()
	})

	fireEvent.click(getByTestId('pack-order-submit'))

	expect(
		container.querySelector(`span[class='dropdown-toggle']`)
	).not.toBeInTheDocument()
	expect(
		container.querySelector(`div[class='dropdown-menu hidden']`)
	).not.toBeInTheDocument()
	expect(
		container.querySelector(`div[class='dropdown-menu']`)
	).not.toBeInTheDocument()
	await waitForExpect(() => {
		expect(getByText('70032370')).toBeInTheDocument()
		expect(getByText('Completed')).toBeInTheDocument()
		expect(container.querySelector(`div[class='dropdown-menu']`)).not.toBeInTheDocument()
	})
})
```



<HalfScreen />

# Create a setup function that will resemble the initial state of the application

```jsx add-challenge.test
function renderAddChallengePage(props = {}, renderOptions = {}) {
  return render(
    <AddChallengePage
      history={{
        push: mockRouterPush,
      }}
      {...props}
    />, { wrapper: RouterWrapper, ...renderOptions}
  )
}

const RouterWrapper = ({ children }) => {
  return (
    <MemoryRouter initialEntries={['/marketing/challenges']}>
      {children}
    </MemoryRouter>
  )
}

const apiPostSpy = jest.spyOn(API.prototype, 'post')
const mockRouterPush = jest.fn()
```

<HalfScreen />

# Mock the database response using tools such as [MSW](https://mswjs.io/)

```js fileName=add-challenge-mock-server
const server = setupServer(
  rest.get(`${GO_HOST}/account-service/store`, async (req, res, ctx) => {
    return res(ctx.json(mockStores))
  }),
  rest.post(
    `${STORE_TECH_HOST}/campaigns/v1.0/campaigns`,
    async (req, res, ctx) => {
      return res(ctx.json({message: 'CREATED'}))
    }
  ),
  rest.get(`${GO_HOST}/ef-customer-core/tags`, async (req, res, ctx) => {
    const { query, limit } = req.url.searchParams

    const response = ctx.json({ tags: [
        createMockTag({ id: 1, name: faker.lorem.word() }),
        createMockTag({ id: 2, name: faker.lorem.word()  }),
    ]})

    if (query || limit) {
      return res(response)
    }
    return res(response)
  }),
)
```

<HalfScreen />

# Create a utility function for repeated behavior

```tsx fileName=fill-challenge-form
export const fillChallengeForm = () => {
  userEvent.type(screen.getByLabelText(/challenge's type/i), faker.lorem.word())
  userEvent.type(
    screen.getByLabelText(/challenge's title/i),
    faker.lorem.words()
  )
  userEvent.type(
    screen.getByLabelText(/max linkpoints cap/i),
    faker.datatype.number()
  )

  userEvent.type(screen.getByLabelText(/start date/i), faker.date.past())
  userEvent.type(screen.getByLabelText(/end date/i), faker.date.future())

  userEvent.type(screen.getByLabelText(/upload icon/i), faker.image.imageUrl())
  userEvent.type(
    screen.getByLabelText(/upload banner/i),
    faker.image.imageUrl()
  )

  // Add a rule
  userEvent.click(screen.getByText(/add rule/i))

  userEvent.type(screen.getByLabelText(/rules title/i), faker.lorem.words())
  userEvent.type(screen.getByLabelText(/min\. spend/i), faker.datatype.number())
  userEvent.type(
    screen.getByLabelText(/bonus linkpoints/i),
    faker.datatype.number()
  )

  // Add a stage
  userEvent.click(screen.getByText(/add stage/i))

  userEvent.selectOptions(
    screen.getByLabelText(/CTA Button Text on Screen/i),
    'Scan'
  )
  userEvent.selectOptions(
    screen.getByLabelText(/^Landing Page$/i),
    'https://test.com/url_a'
  )

  // Add a tip
  userEvent.click(screen.getByText(/add tip/i))
  userEvent.type(screen.getByLabelText(/bullet point/i), faker.lorem.text())
  userEvent.type(screen.getByLabelText(/tips title/i), faker.lorem.words())
  userEvent.type(
    screen.getByLabelText(/campaign page url/i),
    faker.internet.url()
  )
}
```

<HalfScreen />

# Create a test case for each scenario

```jsx fileName=add-challenge.test
test('Create new challenge with rewardsType = fixed && challengeType = order', async () => {
  const page = renderAddChallengePage()

  fillChallengeForm()

  userEvent.click(screen.getByText('Fixed'))
  userEvent.selectOptions((screen.getByPlaceholderText(/challenge type/i), 'Order'))

  userEvent.click(screen.getByText(/submit/i))

  await waitForLoadingToShowThenHide(page)

  expect(apiPostSpy).toHaveBeenCalledWith(
    expect.objectContaining({
      campaignType: CAMPAIGN_TYPE.MS_LP_FIXED,
      rules: [{ awardAmount: 1, minOrderAmount: 1 }],
    })
  )

  expect(mockRouterPush).toHaveBeenCalledWith('/marketing/challenges')
})
```

<HalfScreen />

# Running the tests

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/public/gif/Running-challenges-tests.gif" />

<br />
<br />
<br />

> ### 49 test cases
>
> 5.494(total execution time) - 3(loading time) = 2.494s
>
> 2.5/49 = x/1000
>

<HalfScreen />

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/sign/img/calculating-meme.jpeg?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJpbWcvY2FsY3VsYXRpbmctbWVtZS5qcGVnIiwiaWF0IjoxNjQyNTE0NTUzLCJleHAiOjE5NTc4NzQ1NTN9.-hQ5aoSi2S4EnAW4wBybJtiXu8TYdCFt3gCogSNUJCM" />
<p style={{textAlign: 'center'}}>computing...</p>

<br />
<br />

> x = 51.20

<HalfScreen />

# How about the coverage?

<Img width="1397" height="146" src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/sign/img/Screenshot 2022-01-18 at 3.04.52 PM.png?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJpbWcvU2NyZWVuc2hvdCAyMDIyLTAxLTE4IGF0IDMuMDQuNTIgUE0ucG5nIiwiaWF0IjoxNjQyNTE0MDI4LCJleHAiOjE5NTc4NzQwMjh9.pPaFWrTTQ64jpmnQKHLPq3pAJGWzWSkKRfdpFHdoeu4" />

<HalfScreen />

# How are we able to achieve this with fewer test cases?

<h2 style={{textAlign: 'center'}}>Write only essential code to make a feature test pass</h2>


# [YAGNI (You aren't gonna need it)](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)

# [KISS (keep it simple, stupü§¨d)](https://en.wikipedia.org/wiki/KISS_principle)

<HalfScreen />

# Wait a minute!

<h2 style={{textAlign: 'center'}}>Those are not unit tests...</h2>

<HalfScreen />

# Behavior Based Tests

<h2 style={{textAlign: 'center'}}>Test Driven Development(TDD) ‚û°Ô∏è Behavior Driven Development(BDD)</h2>

<HalfScreen />

# When do we use unit testing that we once knew?

<HalfScreen />

# For edge cases that is impossible to replicate or does not make any sense

<HalfScreen />

```js fileName=generate-challenge.util
const fromApiFormat = ({ customerSegment }, segmentFields) => {
	// ...
  let updatedCustomerSegment

	switch (customerSegment) {
		case 'new':
			updatedCustomerSegment = segmentFields.new
			break
		case 'returning':
			updatedCustomerSegment = segmentFields.returning
			break
		// ...other switch cases
		default:
			throw new Error('Unhandled customer segment')
	}

  // ...
}
```

<br />
<br />

```ts fileName=generate-challenge.util.test
test('should not throw an error when some fields are missing', () => {
  const mockChallenge = createMockChallenge({
    customerSegment: undefined,
  })
  expect(() => fromApiFormat(mockChallenge)).toThrow('Parsing error')
})
```

<HalfScreen />

# Conclusion

## Requirements

- ### Write only tests that reflect the business logic
- ### Write only unit tests for edge cases
- ### Utilize modern tooling

<br />

## Benefits

- ### Tests serve as documentation of feature requirements
- ### Tests are refactor friendly
- ### Faster
- ### Less code, more coverage

<HalfScreen />

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/public/gif/ThankYouGif.gif" />

<HalfScreen />