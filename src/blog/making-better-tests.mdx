---
title: Creating more effective unit tests
description: How to speed up and get more value by writing less tests
date: '2022-01-21'
dateUpdated: '2022-01-21'
bannerId: 7E2ZI7pmLjYwclCitRLek
bannerDescription: eye test
tags: ['testing']
keywords: ['test', 'jest', 'react']
published: true
---


<HalfScreen />

# Problem

<h2 style={{textAlign: 'center'}}>Unit tests that take forever to run</h2>

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/sign/img/testing-meme.png?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJpbWcvdGVzdGluZy1tZW1lLnBuZyIsImlhdCI6MTY0MjUyMTA5NCwiZXhwIjoxOTU3ODgxMDk0fQ.kBnV7cTpCxx70qup9RozOjiSNLLx4Ju0h_V15NnHfg0" />

<HalfScreen />

# Why do even we care?

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/sign/img/Unit-test-meme-2.jpeg?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJpbWcvVW5pdC10ZXN0LW1lbWUtMi5qcGVnIiwiaWF0IjoxNjQyNjYxOTU2LCJleHAiOjE5NTgwMjE5NTZ9.dv9LyIcfFkWannO1cBMKAlo7v56Bat-nY-PIiLeOHBo" />

<HalfScreen />

# Fastest solution

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/sign/img/meme-there-is-no-test-production-only-there-is.jpeg?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJpbWcvbWVtZS10aGVyZS1pcy1uby10ZXN0LXByb2R1Y3Rpb24tb25seS10aGVyZS1pcy5qcGVnIiwiaWF0IjoxNjQyNjYxNjg3LCJleHAiOjE5NTgwMjE2ODd9.SJ9Ce9Djit9VGaZZK7phFehEgMdcx2N65LcmCjmwk7Y" />

<HalfScreen />

# Having a well-defined tests, not only give the business-side a sense of product maintainability, it also give developers the confidence to make changes without breaking crucial functionality.

<HalfScreen />

# As automation practices(CI/CD, DevOps) become common now, it is important to know that automated test is a key factor to make it more effective.

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/sign/img/cicd-pipelines_devops.webp?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJpbWcvY2ljZC1waXBlbGluZXNfZGV2b3BzLndlYnAiLCJpYXQiOjE2NDI1MTY2NDYsImV4cCI6MTk1Nzg3NjY0Nn0.DZtesM4TZKTnzx_-w8Ec8I_o6NTirUZLfvaygddZnB0" />

<HalfScreen />

# Is unit testing slow?


<HalfScreen />

# Unit test is supposed to be fast.

## If your test is slow, you are probably doing something wrong.

<HalfScreen />

# Why tests are running slow in my pipeline?

<HalfScreen />

# Too many tests... ü§Ø

<HalfScreen />

# Concerete example

<h3 style={{textAlign: 'center'}}>Due to the hardcore practice of TDD, early adopters of the convention tried to write tests for everything (even the trivial ones).</h3>

```jsx
test('Initialize OrderLog component', () => {
	const props = {
		url: 'customer-support/orders/order-log/10085807',
		match: {
			params: { id: 10085807 },
		},
	}
	const wrapper = shallow(<OrderLog {...props} />)

	expect(wrapper).toBeTruthy()
})
```

<br />
<br />
<br />

```js
test('Product Form should update store status', () => {
	const productForm = new ProductForm({});

	productForm.setState = () => {};
	productForm.updateState = () => {};

	productForm.updateStoreStatus(['4712052989979'], true, 4, 0);

	expect(productForm.getStatus()).toBe('4712052989979')
});
```

<HalfScreen />


## As days, weeks, months, and years pass, developers come and go; new developers start refactoring the code according to what they see fit.
## However, some developers do not dare touch the unit tests that are already working.


<br />

### How come those "orphaned test case" still exists?

<HalfScreen />

<Img src="https://i.imgur.com/tDHXanY.gif" />

<HalfScreen />

# What is the solution???

<HalfScreen />

<h1 style={{color: 'red'}}>Warning!Ô∏è!Ô∏è!Ô∏è</h1>
<h2 style={{textAlign: 'center', color: 'orangered'}}>Some devs might find this subjective and disturbing</h2>

<h3 style={{textAlign: 'center'}}>Viewer discretion is advised</h3>


<HalfScreen />

# Design your tests to a level where you can get around 90% coverage with lesser tests

<HalfScreen />

# It is easier said than done, isn't it? ü§¶üèª‚Äç‚ôÇÔ∏è

<HalfScreen />

# How can we get a 100% coverage?

```js
const oneOutput = () => 'foo';

// test file
test('oneOutput() should return foo', () => {
	expect(oneOutput()).toBe('foo');
})
```

<HalfScreen />

# Conditional branching

```js
const twoOutputs = (bool) => {
  if (bool === true) {
    return 'foo';
  }

  return 'bar';
}

// test files
test('twoOutputs(true) should return foo', () => {
	expect(twoOutputs(true)).toBe('foo');
})

test('twoOutputs(false) should return foo', () => {
	expect(twoOutputs(false)).toBe('bar');
})
```

<HalfScreen />

# Demo of the feature we are going to test

<h2 style={{textAlign: 'center'}}>Marketing Challenges Campaign</h2>

- ### Challenges Listing Page
- ### Add Challenge Page
- ### Edit(with Delete) Challenge Page

<HalfScreen />

# How to create tests for multiple scenarios

1. ### Create a setup function that will resemble the initial state of the application
2. ### Mock the server responses using tools such as [MSW](https://mswjs.io/)
3. ### Create a utility function for repeated behavior
4. ### Create a test case for each scenario

<HalfScreen />

# Or you prefer to test this way

```jsx fileName=Details.test
test('It should not render delivery order actions menu for completed order', async () => {
	jest.mock('../../../../lib/api', (orderResp) => {
			const mock = require('../../../../../mocks')
			return jest.fn(function () {
					(this.cancel = () => { }),
							(this.get = () =>
									Promise.resolve({
											code: 200,
											status: 'SUCCESS',
											data: {
													config: {
															communication: {
																	allowCall: null,
																	allowEmail: null,
																	allowSms: null
															}
													},
											},
											deliveryOrder: mock.deliveryOrderResponse.deliveryOrder
									})
							),
							(this.post = () =>
									Promise.resolve({ code: 200 })
							)
			})
	})

	const props = {
			url: 'operations/delivery-orders/70032370',
			router: {
					match: {
							params: { id: 70032370 },
							url: 'operations/delivery-orders/70032370',
					}
			},
			history: ['/']
	}

	const DeliveryOrderDetailsView = require('./index').default
	const { container, getByText,
			getByLabelText, getByTestId } = render(
					<MemoryRouter>
							<DeliveryOrderDetailsView
									{...props}
							/>
					</MemoryRouter>
			)

	await waitForExpect(() => {
		expect(getByText('70032370')).toBeInTheDocument()
		expect(getByText('Pending')).toBeInTheDocument()
		expect(container.querySelector(`div[class='dropdown-menu hidden']`)).toBeInTheDocument()
	})

	const modalPortal = document.createElement('div');
	modalPortal.setAttribute('id', 'portal');
	document.body.append(modalPortal);

	const openAction = getByTestId('order-status-actions-icon-web');
	fireEvent.click(openAction);
	await waitForExpect(() => {
			expect(container.querySelector(`div[class='dropdown-menu']`)).toBeInTheDocument()
			expect(getByText('Pack Order')).toBeInTheDocument()
	})

	const packOrder = getByText('Pack Order')
	fireEvent.click(packOrder)

	await waitForExpect(() => {
			expect(getByText('Submit')).toBeInTheDocument()
			expect(getByText('Full Pick')).toBeInTheDocument()
	})
	fireEvent.click(getByLabelText('Full Pick'))

	await waitForExpect(() => {
			expect(getByText('Submit')).toBeInTheDocument()
	})

	fireEvent.click(getByTestId('pack-order-submit'))

	expect(
		container.querySelector(`span[class='dropdown-toggle']`)
	).not.toBeInTheDocument()
	expect(
		container.querySelector(`div[class='dropdown-menu hidden']`)
	).not.toBeInTheDocument()
	expect(
		container.querySelector(`div[class='dropdown-menu']`)
	).not.toBeInTheDocument()
	await waitForExpect(() => {
		expect(getByText('70032370')).toBeInTheDocument()
		expect(getByText('Completed')).toBeInTheDocument()
		expect(container.querySelector(`div[class='dropdown-menu']`)).not.toBeInTheDocument()
	})
})
```

<HalfScreen />

# 1. Create a setup function that will resemble the initial state of the application

```jsx add-challenge.test
function renderAddChallengePage(props = {}, renderOptions = {}) {
  return render(
    <AddChallengePage
      history={{
        push: navigateTo,
      }}
      {...props}
    />, { wrapper: RouterWrapper, ...renderOptions}
  )
}

const RouterWrapper = ({ children }) => {
  return (
    <MemoryRouter initialEntries={['/marketing/challenges']}>
      {children}
    </MemoryRouter>
  )
}

const postRequest = jest.spyOn(API.prototype, 'post')
const navigateTo = jest.fn()
```

<HalfScreen />

# 2. Mock the server response using tools such as [MSW](https://mswjs.io/)

```js fileName=add-challenge-mock-server
const server = setupServer(
  rest.get(`${GO_HOST}/account-service/store`, async (req, res, ctx) => {
    return res(ctx.json(mockStores))
  }),
  rest.post(
    `${STORE_TECH_HOST}/campaigns/v1.0/campaigns`,
    async (req, res, ctx) => {
      return res(ctx.json({message: 'CREATED'}))
    }
  ),
  rest.get(`${GO_HOST}/ef-customer-core/tags`, async (req, res, ctx) => {
    const { query, limit } = req.url.searchParams

    const response = ctx.json({ tags: [
        createMockTag({ id: 1, name: faker.lorem.word() }),
        createMockTag({ id: 2, name: faker.lorem.word()  }),
    ]})

    if (query || limit) {
      return res(response)
    }
    return res(response)
  }),
)
```

<HalfScreen />

# 3. Create a utility function for repeated behavior

```tsx fileName=fill-challenge-form
export const fillMandatoryFields = () => {
  userEvent.type(screen.getByLabelText(/challenge's type/i), faker.lorem.word())
  userEvent.type(
    screen.getByLabelText(/challenge's title/i),
    faker.lorem.words()
  )
  userEvent.type(
    screen.getByLabelText(/max linkpoints cap/i),
    faker.datatype.number()
  )

  userEvent.type(screen.getByLabelText(/start date/i), faker.date.past())
  userEvent.type(screen.getByLabelText(/end date/i), faker.date.future())

  userEvent.type(screen.getByLabelText(/upload icon/i), faker.image.imageUrl())
  userEvent.type(
    screen.getByLabelText(/upload banner/i),
    faker.image.imageUrl()
  )

  // Add a rule
  userEvent.click(screen.getByText(/add rule/i))

  userEvent.type(screen.getByLabelText(/rules title/i), faker.lorem.words())
  userEvent.type(screen.getByLabelText(/min\. spend/i), faker.datatype.number())
  userEvent.type(
    screen.getByLabelText(/bonus linkpoints/i),
    faker.datatype.number()
  )

  // Add a stage
  userEvent.click(screen.getByText(/add stage/i))

  userEvent.selectOptions(
    screen.getByLabelText(/CTA Button Text on Screen/i),
    'Scan'
  )
  userEvent.selectOptions(
    screen.getByLabelText(/^Landing Page$/i),
    'https://test.com/url_a'
  )

  // Add a tip
  userEvent.click(screen.getByText(/add tip/i))
  userEvent.type(screen.getByLabelText(/bullet point/i), faker.lorem.text())
  userEvent.type(screen.getByLabelText(/tips title/i), faker.lorem.words())
  userEvent.type(
    screen.getByLabelText(/campaign page url/i),
    faker.internet.url()
  )
}
```

<HalfScreen />

# 4. Create a test case for each scenario

```jsx fileName=add-challenge.test
test('Create new challenge with rewardsType = fixed && challengeType = order', async () => {
  const page = renderAddChallengePage()

  fillMandatoryFields()

  userEvent.click(screen.getByText('Fixed'))
  userEvent.selectOptions((screen.getByPlaceholderText(/challenge type/i), 'Order'))

  userEvent.click(screen.getByText(/submit/i))

  await waitForLoadingToShowThenHide(page)

  expect(postRequest).toHaveBeenCalledWith(
    expect.objectContaining({
      campaignType: CAMPAIGN_TYPE.MS_LP_FIXED,
      rules: [{ awardAmount: 1, minOrderAmount: 1 }],
    })
  )

  expect(navigateTo).toHaveBeenCalledWith('/marketing/challenges')
})
```

<HalfScreen />

# Running the tests

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/public/gif/Running-challenges-tests.gif" />

<br />
<br />
<br />

> ### 49 test cases
>
> 5.494(total execution time) - 3(loading time) = 2.494s
>
> 2.5/49 = x/1000
>

<HalfScreen />

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/sign/img/calculating-meme.jpeg?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJpbWcvY2FsY3VsYXRpbmctbWVtZS5qcGVnIiwiaWF0IjoxNjQyNTE0NTUzLCJleHAiOjE5NTc4NzQ1NTN9.-hQ5aoSi2S4EnAW4wBybJtiXu8TYdCFt3gCogSNUJCM" />
<p style={{textAlign: 'center'}}>computing...</p>

<br />
<br />

> x = 51.20s

<HalfScreen />

# How about the coverage?

<Img width="1397" height="146" src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/sign/img/Screenshot 2022-01-18 at 3.04.52 PM.png?token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1cmwiOiJpbWcvU2NyZWVuc2hvdCAyMDIyLTAxLTE4IGF0IDMuMDQuNTIgUE0ucG5nIiwiaWF0IjoxNjQyNTE0MDI4LCJleHAiOjE5NTc4NzQwMjh9.pPaFWrTTQ64jpmnQKHLPq3pAJGWzWSkKRfdpFHdoeu4" />

<HalfScreen />

# How are we able to achieve this with fewer test cases?

<HalfScreen />

# Write only essential code to make a feature test pass

# [YAGNI (You aren't gonna need it)](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it)

# [KISS (keep it simple, stupü§¨d)](https://en.wikipedia.org/wiki/KISS_principle)

<HalfScreen />

<h2 style={{textAlign: 'center'}}>Code will have 100% coverage naturally</h2>
<h3 style={{textAlign: 'center'}}>(even helper and private functions will get covered)</h3>

<HalfScreen />

# Wait a minute!

<h2 style={{textAlign: 'center'}}>Those are not unit tests...</h2>

<HalfScreen />

# Behavior Based Tests

<h2 style={{textAlign: 'center'}}>Test Driven Development(TDD) ‚û°Ô∏è Behavior Driven Development(BDD)</h2>

<HalfScreen />

# When do we use unit testing that we once knew?

<HalfScreen />

# For edge cases that is impossible to replicate or does not make any sense

<HalfScreen />

```js fileName=generate-challenge.util
export const fromApiFormat = ({ customerSegment }, segmentFields) => {
	// ...
  let updatedCustomerSegment

	switch (customerSegment) {
		case 'new':
			updatedCustomerSegment = segmentFields.new
			break
		case 'returning':
			updatedCustomerSegment = segmentFields.returning
			break
		// ...other switch cases
		default:
			throw new Error('Unhandled customer segment')
	}

  // ...
}
```

<br />
<br />

```ts fileName=generate-challenge.util.test
test('should not throw an error when some fields are missing', () => {
  const mockChallenge = createMockChallenge({
    customerSegment: undefined,
  })
  expect(() => fromApiFormat(mockChallenge)).toThrow('Unhandled customer segment')
})
```

<HalfScreen />

# Summary

## Requirements

- ### Write only tests that reflect the business logic
- ### Utilize modern tooling
- ### Write only unit tests for edge cases

<br />

## Benefits

- ### Faster
- ### Less code, more coverage
- ### Tests serve as documentation of feature requirements
- ### Tests are refactor/optimization friendly

<HalfScreen />

<Img src="https://xvcorfohslswcnlfcndv.supabase.in/storage/v1/object/public/gif/ThankYouGif.gif" />

<HalfScreen />