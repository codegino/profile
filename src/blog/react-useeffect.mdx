---
title: React useEffect Hook 
description: An introduction on how to use useEffect Hook in your React application
date: '2021-11-10'
bannerId: https://i.imgur.com/SaIYEzo.png
bannerDescription: ripple effect
tags:
  - react
  - tech
published: true 
---

## What is a `useEffect` Hook?

> ### TLDR
> React `useEffect` is an alternative to the "old" `class` lifecycle methods/hooks.
> It can be used to manage side effects, such as network requests, or to run a piece of code when the component is mounted, updated, or unmounted.

### Longer version

> Prior to `React v16.8`, we can only enable a component
> to react to state changes using [lifecycle methods](https://reactjs.org/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class).

#### How to define a `useEffect`

```jsx
useEffect(() => { //(1) declaration
  // (2)effect
  return () => {
    // (3)cleanup 
  }
}, /* (4)dependency array */)
```

#### Here's a quick explanation of the above code:

1. We can declare an effect by calling either `React.useEffect` or `useEffect`
2. `effect` is the function that will be called when the component is mounted
OR when the dependency array changes.
3. `cleanup` is the function that will be called when the effect "unmounted".
4. `dependency array` is the array of values that will be passed to the `effect` function.
    - If there is no dependency array, the effect will be called every time the component is mounted.
    - If the array is empty, the effect will be called only once when the component is mounted.
    - If the array is not empty, the effect will be called every time the component is mounted and the dependency array changes.


### Examples
<br />

#### Fetch data from an API
```jsx
function App() {
  const [data, setData] = useState(null)

  useEffect(() => {
    fetch('https://api.github.com/users/facebook/repos')
      .then(res => res.json())
      .then(data => setData(data))
  }, [])

  // Render the component
}
```

#### Store a value in localStorage everytime the key or value changes
```jsx
function App({ key }) {
  const [value, setValue] = useState(() => localStorage.getItem(key))

  useEffect(() => {
    localStorage.setItem(key, value)
  }, [key, value])
  // Ignore old keys for now

  // Render the component
}
```

#### Increment a counter every second until it reaches 10
```jsx
function App() {
  const [count, setCount] = useState(0)

  useEffect(() => {
    const interval = setInterval(() => {
      setCount(count + 1)
    }, 1000)

    return () => clearInterval(interval)
  }, [])

  // Render the component
}
```

#### Run code during mounted, updated, or unmounted phase

Check this [blog](https://carlogino.cc/blog/react-usestate-callback-function) on how to
convert a class lifecycle methods to `useEffect` hooks

<br />

### Additional Note
- You can only define one of each lifecycle method in a `class` component.
When using hooks you can define as many `useEffect` as you want.
- Keep in mind that the order of the `useEffect` is important.

<br />

## Conclusion
React hooks provide a new and "easier" way to manage side-effects in your React application.


