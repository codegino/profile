---
title: Remix and Supabase integration
description: How to start working on a Remix project
date: '2021-11-27'
bannerId: https://i.imgur.com/HcLHCJR.jpg
bannerDescription: integration
tags:
  - react
  - tech
  - remix
published: true 
---

### Create a Remix project

#### Refer to this [blog](https://codegino.com/blog/remix-getting-started)

#### Prerequisites

- Make sure you have [node](https://nodejs.org/en/) installed
- Basic understanding of [React](https://reactjs.org/)
- Basic `cli` knowledge


#### Installation

```sh noLine
npx create-remix@latest
cd [whatever you named the project]
```

#### Cleaning up

```sh noLine
# Remove demo files
rm -rf app/routes/demos app/styles/demos

# We'll recreate this files later
rm app/routes/index.tsx app/root.tsx
```


#### Re-create file `root.tsx` file under `app` folder.

```tsx fileName=app/root
import {Links,LiveReload,Meta,Outlet,Scripts,ScrollRestoration,} from "remix";

export default function App() {
  return (
    <Document>
      <Layout>
        <Outlet />
      </Layout>
    </Document>
  );
}

function Document({
  children,
  title,
}: {
  children: React.ReactNode;
  title?: string;
}) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        {title ? <title>{title}</title> : null}
        <Meta />
        <Links />
      </head>
      <body>
        {children}
        <ScrollRestoration />
        <Scripts />
        {process.env.NODE_ENV === "development" && <LiveReload />}
      </body>
    </html>
  );
}

function Layout({children}: React.PropsWithChildren<{}>) {
  return (
    <main>{children}</main>;
  );
}
```


#### Re-create file `index.tsx` file under `app/routes` folder.

```tsx fileName=app/routes/index
export default function Index() {
  return (
    <div>
      <h1>Hello world</h1>
    </div>
  );
}
```

# HELLO WORLD IMAGE HERE

### Create a Supabase project

Refer to their official [documentation](https://supabase.com/docs/guides/with-react#create-a-project) on how to create a Supabase project.

#### Create words table
```sql noLine
CREATE TABLE words (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name varchar NOT NULL,
  definitions varchar ARRAY NOT NULL,
  sentences varchar ARRAY NOT NULL,
  type varchar NOT NULL
);
```

#### Add a new word
```sql noLine
INSERT INTO words
  (name, type, definitions, sentences)
VALUES
  ('hello', 'noun', ARRAY['used as a greeting'], ARRAY['Hello world.']);
```


#### Add anonymous access

```sql noLine
ALTER TABLE words ENABLE ROW LEVEL SECURITY;

CREATE POLICY "anon_select" ON public.words FOR SELECT USING (
  auth.role() = 'anon'
);

CREATE POLICY "anon_insert" ON public.words FOR INSERT WITH CHECK (
  auth.role() = 'anon'
);

CREATE POLICY "anon_update" ON public.words FOR UPDATE USING (
  auth.role() = 'anon'
);

CREATE POLICY "anon_delete" ON public.words FOR DELETE USING (
  auth.role() = 'anon'
);
```

### Integration Prerapations

#### Install Supabase
```sh noLine
npm install @supabase/supabase-js
```

### Create a Supabase client utility

#### Create an `.env` file to hold your Supabase credentials.

```.env
SUPABASE_ANON_KEY=YOUR_SUPABASE_ANON_KEY
SUPABASE_URL=YOUR_SUPABASE_URL
```

#### Create a Supabase client utility for reusability

```ts libs/supabase-client
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = process.env.SUPABASE_URL as string;
const supabaseKey = process.env.SUPABASE_ANON_KEY as string;

export const supabase = createClient(supabaseUrl, supabaseKey);
```

### Chores before integration

#### Redirect `/` to `/words`

Since I'm planning to create multiple mini app in this project, I'll redirect `/` to `/words`, for now.
This will ensure we don't need to manually navigate to `/words` every time we open the root page.

```tsx fileName=app/routes/index
import { redirect } from "remix";

export function loader() {
  return redirect("/words", 308);
}
```

## Integrating Supabase with Remix

### Create the words listing page

#### (OPTIONAL)Create type definition
```ts fileName=app/models/word
export enum WordType {
  NOUN = "noun",
  VERB = "verb",
  ADJECTIVE = "adjective",
}

export type Word = {
  id: number;
  name: string;
  sentences: string[];
  definitions: string[];
  type: WordType;
};
```

#### fetch data from Supabase using Remix's `loader`

```tsx fileName=app/routes/words
import type { LoaderFunction } from "remix";
import { supabase } from "~/libs/supabase-client";
import { Word } from "~/models/word";

export const loader: LoaderFunction = async () => {
  const { data: words } = await supabase
    .from<Word>("words")
    .select("id,name,type");

  // We can pick and choose what we want to display
  // This can solve the issue of over-fetching or under-fetching
  return words;
};
```

#### Create a React component to display the list of words 

```tsx fileName=app/routes/words
import { useLoaderData } from "remix";

// export const loader ...

export default function Index() {
  const words = useLoaderData<Word[]>();

  return (
    <div>
      <h1>English words I learned</h1>
      <ul>
        {words.map((word) => (
          <li key={word.id}>
            <div>
              <Link to={`/words/${word.id}`}>
                {word.name} | {word.type}
              </Link>
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

# Image of above code here


### Create the word details page

#### Create file `$id.tsx` under `app/routes/words` folder.

##### Create the loader function

```tsx fileName=app/routes/words/$id
import type { LoaderFunction } from "remix";
import { supabase } from "~/libs/supabase-client";
import { Word } from "~/models/word";

export const loader: LoaderFunction = async ({ params }) => {
  const { data } = await supabase
    .from<Word>("words")
    .select("*")
    .eq("id", params.id as string)
    .single();

  return data;
};
```

##### Create the component

```tsx fileName=app/routes/words/$id
// import ...

// export const loader ...

export default function Word() {
  const word = useLoaderData<Word>();

  return (
    <div>
      <h3>
        {word.name} | {word.type}
      </h3>
      {word.definitions.map((definition, i) => (
        <p key={i}>
          <i>{definition}</i>
        </p>
      ))}
      {word.sentences.map((sentence, i) => (
        <p key={i}>{sentence}</p>
      ))}
    </div>
  );
}
```

# Show image of result (details should not be visible, yet)

##### Adding a router `Outlet`

```tsx fileName=app/routes/words
import {/*other imports*/, Outlet} from "remix";

// export const loader ...

export default function Index() {
  const words = useLoaderData<Word[]>();

  return (
    <div>
      <h1>New words I learned</h1>
      <div style={{ display: "flex", justifyContent: "space-between" }}>
        <ul>
          {words.map((word) => (
            <li key={word.id}>
              <Link to={`/words/${word.id}`}>
                {word.name} | {word.type}
              </Link>
            </li>
          ))}
        </ul>
        <Outlet /> {/* <-- this is where $id.tsx will render */}
      </div>
    </div>
  );
}
```

# Show $id.tsx result


### Delete a word entry

Since we're already on the `/words/$id` page, let's proceed with deletion first

#### Add a button to delete the word

```tsx fileName=app/routes/words/$id
export default function Index() {
  // ...

  return (
    <div>
      {/* previous contents */}
      <Form method="post">
        <input type="hidden" name="_method" value="delete" />
        <button type="submit">Delete</button>
      </Form>
    </div>
  );
}
```

# Show error after clicking submit button

#### Delete the word in the database using Remix's `action`

```tsx fileName=app/routes/words/$id
import { /*other imports*/, redirect} from "remix";
import type {/*other imports*/, ActionFunction} from "remix";

export const action: ActionFunction = async ({ request, params }) => {
  const formData = await request.formData();

  if (formData.get("_method") === "delete") {
    await supabase
      .from<Word>("words")
      .delete()
      .eq("id", params.id as string);

    return redirect("/words");
  }
};
```

# Show GIF of result`

##### Explanation:
- Create a form with a hidden input field named `_method` with value `delete`.
- When the submit button is clicked, the `action` handler will trigger in the server.
- Inside the `action` handler, we check if the `_method` is `delete`.
- If it is, we delete the word from the database.

##### Why go through all this trouble?

It just happens that this approach does not need any JavaScript to run.
As a matter of fact, the previous GIF demo had the JavaScript disabled.
This means our app is interactive even before we load the JavaScript from the server.
 

### Create a new word entry

#### Create a button in the `/words` page to create a new word

```tsx fileName=app/routes/words
import { /*other imports*/ useNavigate } from "remix";

// export const loader ...

export default function Index() {
  // const words ...
  const navigate = useNavigate();

  return (
    <div>
      <h1>New words I learned</h1>
      <button onClick={() => navigate("/words/add")}>Add new word</button>
      {/* previous contents */}
    </div>
  );
}
```

#### Create the add new word route

To avoid a `404` page, let's create a `/add` route.

##### Create the component

```tsx fileName=app/root/add
import {Form} from "remix";

export default function AddWord() {
  return (
    <Form method="post">
      <div>
        <label htmlFor="name">Word</label>
        <input id="name" name="name" type="text" placeholder="Word" required />
      </div>
      <div>
        <label htmlFor="type">Type</label>
        <select id="type" name="type" defaultValue={WordType.NOUN}>
          <option value={WordType.NOUN}>Noun</option>
          <option value={WordType.VERB}>Verb</option>
          <option value={WordType.ADJECTIVE}>Adjective</option>
        </select>
      </div>
      <div>
        <label htmlFor="sentence.1">Sentence</label>
        <textarea
          id="sentence.1"
          name="sentence"
          placeholder="Sentence"
          minLength={10}
        />
      </div>
      <div>
        <label htmlFor="definition.1">Definition</label>
        <textarea
          id="definition.1"
          name="definition"
          placeholder="Definition"
          minLength={10}
        />
      </div>
      <button type="submit">Submit</button>
    </Form>
  );
}
```

##### Add an action

To avoid getting the missing action error

```tsx
import { /*other imports*/, redirect } from "remix";
import type { ActionFunction } from "remix";
import { supabase } from "~/libs/supabase-client";

export const action: ActionFunction = async ({ request }) => {
  const formData = await request.formData();

  const newWord = {
    name: formData.get("name"),
    type: formData.get("type"),
    sentences: formData.getAll("sentence"),
    definitions: formData.getAll("definition"),
  };

  await supabase.from("words").insert([newWord]);

  return redirect("/words");
};
```

# Show GIF of result

### Edit a word entry

#### Create a file named `edit.$id.tsx` under `app/routes/words`

When we add a `.` between words, it will tranform to `/`.
The above example will result to `words/edit/[id]`.

##### Create a form for editing the word

Since the edit form is very similar to the add form, we can reuse the same Form with additional checks to determine if we are adding or editing.

```tsx fileName=app/components/WordForm
import { Form } from "remix";
import { Word, WordType } from "~/models/word";

export default function WordForm({ word }: { word?: Word }) {
  return (
    <Form method="post">
      <div>
        <label htmlFor="name">Word</label>
        <input
          id="name"
          name="name"
          type="text"
          placeholder="Word"
          required
          defaultValue={word?.name ?? ""}
          disabled={Boolean(word?.name)}
        />
      </div>
      <div>
        <label htmlFor="type">Type</label>
        <select
          id="type"
          name="type"
          defaultValue={word?.type ?? WordType.NOUN}
        >
          <option value={WordType.NOUN}>Noun</option>
          <option value={WordType.VERB}>Verb</option>
          <option value={WordType.ADJECTIVE}>Adjective</option>
        </select>
      </div>
      <div>
        {word?.sentences.map((sentence, i) => (
          <SentenceField index={i + 1} sentence={sentence} key={i} />
        )) ?? <SentenceField index={1} sentence={""} />}
      </div>
      <div>
        {word?.definitions.map((definition, i) => (
          <DefinitionField index={i + 1} definition={definition} key={i} />
        )) ?? <DefinitionField index={1} definition={""} />}
      </div>
      <button type="submit">Submit</button>
    </Form>
  );
}

const SentenceField = ({ index, sentence }) => (
  <div>
    <label htmlFor={`sentence.${index}`}>Sentence #{index}</label>
    <textarea
      id={`sentence.${index}`}
      name="sentence"
      defaultValue={sentence}
      placeholder={`Sentence #${index}`}
      minLength={10}
    />
  </div>
);

const DefinitionField = ({ index, definition }) => (
  <div>
    <label htmlFor={`definition.${index}`}>Definition #{index}</label>
    <textarea
      id={`definition.${index}`}
      name="definition"
      defaultValue={definition}
      placeholder={`Definition #${index}`}
      minLength={10}
    />
  </div>
);
```

<br />

That's a lot of code; however, we can reap the benefits since we can simplify the usage in `add.tsx` and `edit.$id.tsx`.

##### Update `routes/words/add.tsx`

```tsx fileName=app/routes/words/add
// other code...

export default function AddWord() {
  return <WordForm />;
}
```

##### Create `routes/words/edit.$id.tsx`

```tsx fileName=app/routes/words/edit.$id
export default function EditWord() {
  const data = useLoaderData<Word>();

  return <WordForm word={data} />;
}
```

Now, we have a reusable form. If we have a style update, we can update the `WordForm` component.

> NOTE: I'm extracting everything to `WordForm.tsx` since it is applicable in my use case.

##### Create a loader for the word details

```tsx fileName=app/routes/words/edit.$id
import { supabase } from "~/libs/supabase-client";
import type {LoaderFunction} from "remix";

export const loader: LoaderFunction = async ({ params }) => {
  const { data } = await supabase
    .from<Word>("words")
    .select("*")
    .eq("id", params.wordId as string)
    .single();

  return data;
};

// export const EditWord...
```

# Show Image of above result

##### Add an action handler

```tsx fileName=app/routes/words/edit.$id
import {/*other imports*/, redirect} from "remix";
import type {/*other imports*/, ActionFunction} from "remix";

export const action: ActionFunction = async ({ request, params }) => {
  const formData = await request.formData();
  const id = params.wordId as string;

  const updates = {
    type: formData.get("type"),
    sentences: formData.getAll("sentence"),
    definitions: formData.getAll("definition"),
  };

  await supabase.from("words").update(updates).eq("id", id);

  return redirect(`/words/${id}`);
};

// export const loader...

// export const EditWord...
```

# Show GIF of result


<br/>

## Conlusion