---
title: Error handling in Remix
description: How to handle errors gracefully in Remix
date: '2021-12-09'
dateUpdated: '2021-12-09'
bannerId: https://i.imgur.com/ogxFvNx.jpg
bannerDescription: stock market crash 
tags: ['react', 'tech', 'remix']
keywords: ['remix error handling']
published: false
---

## The Complete Guide to Handling Errors in Remix

## TLDR

## Introduction - What are the basics of error handling in Remix?

## How to Handle Unhandled Rejection Errors in Remix 

> **Remix will automatically catch errors and render the nearest error boundary for errors thrown while:**
> - rendering in the browser
> - rendering on the server
> - in a loader during the initial server rendered document request
> - in an action during the initial server rendered document request
> - in a loader during a client-side transition in the browser (Remix serializes the error and sends it over the network to the browser)
> - in an action during a client-side transition in the browser

#### Root Error boundary

```tsx
export function CatchBoundary() {
  let caught = useCatch();

  let message;
  switch (caught.status) {
    case 404:
      message = <p>This is a custom error message for 404 pages</p>;
      break;
    // You can customize the behavior for other status codes
    default: {
      if (process.env.NODE_ENV === "development") {
        throw new Error(JSON.stringify(caught.data) || caught.statusText);
      } else {
        message = (
          <p>
            An error occurred. Please try again later. If the problem persists,
            please contact us.
          </p>
        );
        break;
      }
    }
  }

  return (
    <Document title={`${caught.status} ${caught.statusText}`}>
      <Layout>
        <h1>
          {caught.status}: {caught.statusText}
        </h1>
        {message}
      </Layout>
    </Document>
  );
}
```


### Handling error in Server-side

#### Handling error in a loader

```tsx
import {json} from "remix";
import type {LoaderFunction} from "remix";

export const loader: LoaderFunction = async ({ params }) => {
	// Whatever API you are using
  const { data } = await supabase
    .from<Word>("words")
    .select("*")
    .eq("id", params.id as string)
    .single();

  if (!data) {
		// We structure this anyway we want. It's up to the client-side to handle this.
		const data = {message: "Word could not be found" }

    throw json(data, 404);
  }

  return data;
};
```

#### Handling error in an action 

```tsx
import {json} from "remix";
import type {ActionFunction} from "remix";

export const action: ActionFunction = async ({ params }) => {
	const session = await getSession(request.headers.get("Cookie"));

  const accessToken = session.get("access_token");

	if (!accesToken) {
		throw json(
      {
        message: "Please login",
      },
      { status: 401 }
    );
	}


	// Not related to handling errors
	const { data, error } = await supabase
    .from("words")
    .insert([newWord])
    .single();

  if (error) {
    return redirect(`/words`);
  }

  return redirect(`/words/${data?.id}`);
})

```

### Handling Error in Client-Side

```tsx
export function CatchBoundary() {
	cosnt caught = useCatch();

  return (
		{/*We format this anyway we want*/}
    <section>
      <h2>
        {caught.status}: {caught.statusText}
      </h2>
			{/*We can display here properties set from the backend*/}
      {caught.data && <p>{caught.data.message}</p>}
    </section>
  );
}
```


#### Router Error boundary